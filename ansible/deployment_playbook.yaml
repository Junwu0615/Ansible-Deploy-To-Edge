---
# ----------------------------------------------------
# TODO Play 1: 環境初始化 (只針對實體主機運行一次)
# ----------------------------------------------------
- name: A. 環境初始化 - 安裝必要套件
  hosts: wsl_hosts
  become: true # 需要 root 權限來安裝系統套件和 pip 系統級別套件
  gather_facts: false # 不需要收集主機資訊，節省時間

  tasks:
    # ----------------------------------------------------
    # 任務 A.1: 安裝編譯工具
    - name: A.1 安裝系統套件 ( 開發工具, Python SDK )
      ansible.builtin.apt:
        name:
          - python3-dev
          - python3-docker
          - build-essential
        state: present
        update_cache: true

    # ----------------------------------------------------
    # A.2. 手動下載並安裝 Docker Compose V2 CLI
    - name: A.2.0 確保 Docker CLI 外掛程式目錄存在
      ansible.builtin.file:
        path: /usr/local/lib/docker/cli-plugins
        state: directory
        mode: '0755' # 所有者(讀/寫/執行)、群組(讀/執行)、其他人(讀/執行)

    # 關鍵修正：在下載前，強制移除任何可能存在的舊檔案/連結
    - name: A.2.1 清理舊的 Docker Compose CLI 檔案或連結
      ansible.builtin.file:
        path: /usr/local/lib/docker/cli-plugins/docker-compose
        state: absent # 確保檔案/連結不存在

    - name: A.2.2 下載 Docker Compose V2 二進制檔案 ( get_url 具備 Idempotency )
      ansible.builtin.get_url:
        url: "https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64"
        dest: /usr/local/lib/docker/cli-plugins/docker-compose
        mode: '0755' # 所有者(讀/寫/執行)、群組(讀/執行)、其他人(讀/執行)

    - name: A.2.3 建立 Docker Compose CLI 的軟連結 ( /usr/local/bin )
      ansible.builtin.file:
        src: /usr/local/lib/docker/cli-plugins/docker-compose
        dest: /usr/local/bin/docker-compose
        state: link
        force: true

    - name: A.2.4 建立新版 Docker CLI 連結 ( /usr/bin )
      ansible.builtin.file:
        src: /usr/local/lib/docker/cli-plugins/docker-compose
        dest: /usr/bin/docker-compose
        state: link
        force: true

    # ----------------------------------------------------
    # A.3 清理系統快取 ( 解決空間佔用問題 )
    - name: A.3 清理 Apt 套件快取並移除不必要的相依性 ( 釋放磁碟空間 )
      ansible.builtin.apt:
        autoclean: true
        autoremove: true


# ----------------------------------------------------
# TODO Play 2: 應用程式部署 (針對每個目標裝置迴圈運行)
# ----------------------------------------------------
- name: B. 模擬部署 - 使用 Ansible 將指定服務一鍵下發到所有邊緣裝置
  hosts: device_configs
  become: false # 運行 Docker 通常不需要 root 權限，除非您需要 sudo
  gather_facts: false

  tasks:
    # ----------------------------------------------------
    - name: B.1 確認裝置資訊
      debug:
        msg: "Deploying to {{ inventory_hostname }} with DEVICE_ID={{ DEVICE_ID }}, PORT={{ DEPLOY_PORT }}"

    # ----------------------------------------------------
    - name: B.2 拉取映像檔
      docker_image:
        name: "{{ REGISTRY_HOST_PORT }}/pc-hello-world:latest"
        source: pull

    # ----------------------------------------------------
    - name: B.3 複製 .env 檔案到 /tmp/ ( 執行一次 )
      copy:
        src: "{{ playbook_dir }}/templates/.env"
        dest: "/tmp/.env"
        mode: '0644' # 所有者(讀/寫)、群組(讀)、其他人(讀)
      # 由於 .env 內容對所有裝置都一樣 # 只需執行一次
      run_once: true

    - name: B.4 渲染 docker-compose 檔案
      template:
        src: "{{ playbook_dir }}/templates/docker-compose.yaml.j2"
        # 儲存為一個新的純 YAML 檔案，這樣 docker-compose 才能讀取
        dest: "/tmp/docker-compose-{{ DEVICE_ID | lower }}.yaml"

    # ----------------------------------------------------
    - name: B.5 啟動容器 ( 使用 community.docker.docker_compose )
      community.docker.docker_compose:
        project_name: "{{ DEVICE_ID | lower }}"
        files:
          - "/tmp/docker-compose-{{ DEVICE_ID | lower }}.yaml"
        project_src: /tmp
        state: present # 確保服務存在且運行

    # ----------------------------------------------------
    - name: B.6 驗證容器狀態
      command: docker ps
      register: docker_ps
      changed_when: false

    - debug:
        var: docker_ps.stdout

#    - name: B.6 驗證容器狀態
#      command: docker ps -f name=pc-hello-world-{{ DEVICE_ID | lower }}
#      register: docker_ps
#      changed_when: false
#      failed_when: "'Up' not in docker_ps.stdout"
#      debug:
#        var: docker_ps.stdout